#!/usr/bin/env python3
"""
MCP Integration Examples for CoralCollective
Demonstrates how different agent types can leverage MCP tools effectively
"""

import asyncio
import json
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Optional, Any

# Example usage patterns for different agent types

class BackendDeveloperMCPExample:
    """
    Example showing how Backend Developer agent uses MCP tools
    for database operations, file management, and API development
    """
    
    def __init__(self, bridge):
        self.bridge = bridge
        self.agent_type = "backend_developer"
    
    async def setup_api_project(self, project_name: str) -> Dict[str, Any]:
        """Example: Setting up a new API project with database"""
        results = []
        
        # 1. Create project directory structure
        directories = [
            f"{project_name}/src/api",
            f"{project_name}/src/models",
            f"{project_name}/src/services",
            f"{project_name}/tests",
            f"{project_name}/migrations"
        ]
        
        for dir_path in directories:
            result = await self.bridge.filesystem_write(
                f"{dir_path}/__init__.py", 
                "# Auto-generated by CoralCollective"
            )
            results.append({"action": f"Create directory {dir_path}", "success": result['success']})
        
        # 2. Create main API file
        api_code = '''
from fastapi import FastAPI, HTTPException, Depends
from sqlalchemy.orm import Session
from . import models, schemas, database

app = FastAPI(title="''' + project_name + ''' API")

@app.get("/")
def read_root():
    return {"message": "API is running"}

@app.get("/health")
def health_check():
    return {"status": "healthy", "timestamp": datetime.utcnow()}
'''
        
        result = await self.bridge.filesystem_write(
            f"{project_name}/src/api/main.py", 
            api_code
        )
        results.append({"action": "Create main API file", "success": result['success']})
        
        # 3. Set up database schema
        schema_sql = f'''
CREATE TABLE IF NOT EXISTS users (
    id SERIAL PRIMARY KEY,
    email VARCHAR(255) UNIQUE NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE IF NOT EXISTS {project_name}_data (
    id SERIAL PRIMARY KEY,
    user_id INTEGER REFERENCES users(id),
    data JSONB,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
'''
        
        # Try to execute database schema
        try:
            db_result = await self.bridge.database_query(schema_sql)
            results.append({"action": "Create database schema", "success": True, "result": db_result})
        except Exception as e:
            results.append({"action": "Create database schema", "success": False, "error": str(e)})
        
        # 4. Create GitHub repository
        try:
            repo_result = await self.bridge.github_create_issue(
                title=f"Setup {project_name} API project",
                body=f"Initial setup for {project_name} API with FastAPI and PostgreSQL",
                labels=["setup", "backend"]
            )
            results.append({"action": "Create GitHub issue", "success": repo_result['success']})
        except Exception as e:
            results.append({"action": "Create GitHub issue", "success": False, "error": str(e)})
        
        return {
            "project": project_name,
            "agent": self.agent_type,
            "completed_actions": len([r for r in results if r['success']]),
            "total_actions": len(results),
            "details": results,
            "timestamp": datetime.utcnow().isoformat()
        }
    
    async def deploy_with_docker(self, project_name: str) -> Dict[str, Any]:
        """Example: Deploy API using Docker"""
        
        # Create Dockerfile
        dockerfile_content = '''
FROM python:3.11-slim

WORKDIR /app

COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

COPY src/ ./src/
EXPOSE 8000

CMD ["uvicorn", "src.api.main:app", "--host", "0.0.0.0", "--port", "8000"]
'''
        
        dockerfile_result = await self.bridge.filesystem_write(
            f"{project_name}/Dockerfile",
            dockerfile_content
        )
        
        # Create docker-compose.yml
        compose_content = f'''
version: '3.8'

services:
  api:
    build: .
    ports:
      - "8000:8000"
    environment:
      - DATABASE_URL=postgresql://postgres:password@db:5432/{project_name}
    depends_on:
      - db
      
  db:
    image: postgres:15
    environment:
      - POSTGRES_DB={project_name}
      - POSTGRES_PASSWORD=password
    volumes:
      - postgres_data:/var/lib/postgresql/data
      
volumes:
  postgres_data:
'''
        
        compose_result = await self.bridge.filesystem_write(
            f"{project_name}/docker-compose.yml",
            compose_content
        )
        
        # Build and run containers
        try:
            build_result = await self.bridge.docker_run(
                image="docker/compose",
                command=f"up -d --build",
                env={"COMPOSE_PROJECT_NAME": project_name}
            )
        except Exception as e:
            build_result = {"success": False, "error": str(e)}
        
        return {
            "dockerfile_created": dockerfile_result['success'],
            "compose_created": compose_result['success'],
            "deployment_result": build_result,
            "agent": self.agent_type
        }


class FrontendDeveloperMCPExample:
    """
    Example showing how Frontend Developer agent uses MCP tools
    for UI development, component testing, and deployment
    """
    
    def __init__(self, bridge):
        self.bridge = bridge
        self.agent_type = "frontend_developer"
    
    async def setup_react_project(self, project_name: str) -> Dict[str, Any]:
        """Example: Setting up a React project with components"""
        results = []
        
        # 1. Create project structure
        directories = [
            f"{project_name}/src/components",
            f"{project_name}/src/hooks",
            f"{project_name}/src/utils",
            f"{project_name}/src/styles",
            f"{project_name}/public"
        ]
        
        for dir_path in directories:
            await self.bridge.filesystem_write(f"{dir_path}/.gitkeep", "")
            results.append(f"Created {dir_path}")
        
        # 2. Create main App component
        app_component = f'''
import React from 'react';
import {{ BrowserRouter as Router, Routes, Route }} from 'react-router-dom';
import Header from './components/Header';
import Dashboard from './components/Dashboard';
import './styles/App.css';

function App() {{
  return (
    <div className="App">
      <Router>
        <Header />
        <main>
          <Routes>
            <Route path="/" element={{<Dashboard />}} />
          </Routes>
        </main>
      </Router>
    </div>
  );
}}

export default App;
'''
        
        app_result = await self.bridge.filesystem_write(
            f"{project_name}/src/App.jsx",
            app_component
        )
        results.append(f"Created App component: {app_result['success']}")
        
        # 3. Create a reusable component
        header_component = '''
import React from 'react';
import './Header.css';

const Header = () => {
  return (
    <header className="header">
      <div className="container">
        <h1 className="logo">MyApp</h1>
        <nav>
          <ul className="nav-links">
            <li><a href="/">Home</a></li>
            <li><a href="/about">About</a></li>
            <li><a href="/contact">Contact</a></li>
          </ul>
        </nav>
      </div>
    </header>
  );
};

export default Header;
'''
        
        header_result = await self.bridge.filesystem_write(
            f"{project_name}/src/components/Header.jsx",
            header_component
        )
        results.append(f"Created Header component: {header_result['success']}")
        
        # 4. Test component in E2B sandbox
        try:
            test_code = f'''
import {{ render, screen }} from '@testing-library/react';
import Header from '../components/Header';

test('renders header with navigation', () => {{
  render(<Header />);
  expect(screen.getByText('MyApp')).toBeInTheDocument();
  expect(screen.getByText('Home')).toBeInTheDocument();
}});
'''
            
            test_result = await self.bridge.e2b_execute(test_code, 'javascript')
            results.append(f"Component test executed: {test_result['success']}")
        except Exception as e:
            results.append(f"Component test failed: {str(e)}")
        
        # 5. Search for React best practices
        try:
            search_result = await self.bridge.search_web(
                "React hooks best practices 2024",
                max_results=5
            )
            if search_result['success']:
                results.append(f"Found {len(search_result['result'])} resources on React best practices")
            else:
                results.append("Web search for best practices failed")
        except Exception as e:
            results.append(f"Search failed: {str(e)}")
        
        return {
            "project": project_name,
            "agent": self.agent_type,
            "setup_results": results,
            "timestamp": datetime.utcnow().isoformat()
        }
    
    async def optimize_performance(self, project_name: str) -> Dict[str, Any]:
        """Example: Performance optimization workflow"""
        
        # Create performance monitoring hook
        perf_hook = '''
import { useState, useEffect } from 'react';

export const usePerformanceMonitor = () => {
  const [metrics, setMetrics] = useState({});

  useEffect(() => {
    if ('PerformanceObserver' in window) {
      const observer = new PerformanceObserver((list) => {
        const entries = list.getEntries();
        entries.forEach((entry) => {
          setMetrics(prev => ({
            ...prev,
            [entry.name]: {
              duration: entry.duration,
              startTime: entry.startTime
            }
          }));
        });
      });
      
      observer.observe({ entryTypes: ['measure', 'navigation'] });
      
      return () => observer.disconnect();
    }
  }, []);

  return metrics;
};
'''
        
        hook_result = await self.bridge.filesystem_write(
            f"{project_name}/src/hooks/usePerformanceMonitor.js",
            perf_hook
        )
        
        # Create bundle analyzer script
        analyzer_script = '''
const { BundleAnalyzerPlugin } = require('webpack-bundle-analyzer');

module.exports = {
  webpack: (config, { buildId, dev, isServer, defaultLoaders, webpack }) => {
    if (!dev) {
      config.plugins.push(
        new BundleAnalyzerPlugin({
          analyzerMode: 'static',
          openAnalyzer: false,
        })
      );
    }
    return config;
  },
};
'''
        
        analyzer_result = await self.bridge.filesystem_write(
            f"{project_name}/webpack.config.js",
            analyzer_script
        )
        
        return {
            "performance_hook_created": hook_result['success'],
            "bundle_analyzer_configured": analyzer_result['success'],
            "optimization_recommendations": [
                "Implement code splitting",
                "Add lazy loading for images",
                "Use React.memo for expensive components",
                "Optimize bundle size"
            ]
        }


class QATestingMCPExample:
    """
    Example showing how QA Testing agent uses MCP tools
    for test automation, E2B execution, and quality assurance
    """
    
    def __init__(self, bridge):
        self.bridge = bridge
        self.agent_type = "qa_testing"
    
    async def run_comprehensive_tests(self, project_name: str) -> Dict[str, Any]:
        """Example: Comprehensive testing workflow"""
        test_results = []
        
        # 1. Unit tests
        unit_test = '''
import pytest
from src.models.user import User
from src.services.auth import AuthService

class TestAuthService:
    def test_create_user(self):
        auth_service = AuthService()
        user_data = {"email": "test@example.com", "password": "secure123"}
        
        user = auth_service.create_user(user_data)
        
        assert user.email == "test@example.com"
        assert user.id is not None
        
    def test_login_valid_user(self):
        auth_service = AuthService()
        result = auth_service.login("test@example.com", "secure123")
        
        assert result["success"] is True
        assert "token" in result
        
    def test_login_invalid_credentials(self):
        auth_service = AuthService()
        result = auth_service.login("test@example.com", "wrongpass")
        
        assert result["success"] is False
        assert result["error"] == "Invalid credentials"
'''
        
        # Execute unit tests in E2B
        unit_result = await self.bridge.e2b_execute(unit_test, 'python')
        test_results.append({
            "test_type": "unit_tests",
            "success": unit_result['success'],
            "result": unit_result.get('result', {})
        })
        
        # 2. Integration tests with database
        integration_test = '''
import asyncio
import pytest
from httpx import AsyncClient
from src.main import app
from src.database import TestDatabase

@pytest.mark.asyncio
async def test_api_create_user():
    async with AsyncClient(app=app, base_url="http://test") as client:
        response = await client.post("/users", json={
            "email": "integration@test.com",
            "password": "testpass123"
        })
        
        assert response.status_code == 201
        data = response.json()
        assert "id" in data
        assert data["email"] == "integration@test.com"

@pytest.mark.asyncio  
async def test_api_auth_flow():
    async with AsyncClient(app=app, base_url="http://test") as client:
        # Create user
        create_response = await client.post("/users", json={
            "email": "auth@test.com",
            "password": "testpass123"
        })
        assert create_response.status_code == 201
        
        # Login
        login_response = await client.post("/auth/login", data={
            "username": "auth@test.com",
            "password": "testpass123"
        })
        assert login_response.status_code == 200
        token_data = login_response.json()
        assert "access_token" in token_data
'''
        
        integration_result = await self.bridge.e2b_execute(integration_test, 'python')
        test_results.append({
            "test_type": "integration_tests",
            "success": integration_result['success'],
            "result": integration_result.get('result', {})
        })
        
        # 3. Load testing with Docker
        try:
            load_test_config = '''
version: '3.8'
services:
  load-test:
    image: loadimpact/k6
    volumes:
      - ./load-test.js:/load-test.js
    command: run --vus 10 --duration 30s /load-test.js
'''
            
            config_result = await self.bridge.filesystem_write(
                f"{project_name}/docker-compose.loadtest.yml",
                load_test_config
            )
            
            k6_script = '''
import http from 'k6/http';
import { check, sleep } from 'k6';

export let options = {
  stages: [
    { duration: '10s', target: 10 },
    { duration: '20s', target: 10 },
    { duration: '10s', target: 0 },
  ],
};

export default function() {
  let response = http.get('http://host.docker.internal:8000/');
  check(response, {
    'status is 200': (r) => r.status === 200,
    'response time < 500ms': (r) => r.timings.duration < 500,
  });
  sleep(1);
}
'''
            
            script_result = await self.bridge.filesystem_write(
                f"{project_name}/load-test.js",
                k6_script
            )
            
            # Run load test
            load_result = await self.bridge.docker_run(
                image="loadimpact/k6",
                command="run --vus 10 --duration 30s /load-test.js"
            )
            
            test_results.append({
                "test_type": "load_test",
                "config_created": config_result['success'],
                "script_created": script_result['success'],
                "execution": load_result
            })
            
        except Exception as e:
            test_results.append({
                "test_type": "load_test",
                "success": False,
                "error": str(e)
            })
        
        # 4. Create test report as GitHub issue
        try:
            passed_tests = len([t for t in test_results if t.get('success', False)])
            total_tests = len(test_results)
            
            report = f'''
# Test Execution Report - {project_name}

## Summary
- **Date**: {datetime.utcnow().strftime('%Y-%m-%d %H:%M:%S')} UTC
- **Tests Passed**: {passed_tests}/{total_tests}
- **Success Rate**: {(passed_tests/total_tests)*100:.1f}%

## Test Results

'''
            for result in test_results:
                status = "âœ… PASS" if result.get('success') else "âŒ FAIL"
                report += f"- **{result.get('test_type', 'Unknown')}**: {status}\n"
                if not result.get('success') and 'error' in result:
                    report += f"  - Error: {result['error']}\n"
            
            report += "\n## Recommendations\n"
            if passed_tests == total_tests:
                report += "- All tests passing! Consider adding more edge cases.\n"
                report += "- Monitor performance metrics in production.\n"
            else:
                report += "- Fix failing tests before deployment.\n"
                report += "- Review error logs for detailed debugging info.\n"
            
            issue_result = await self.bridge.github_create_issue(
                title=f"Test Report - {project_name} ({passed_tests}/{total_tests} passed)",
                body=report,
                labels=["testing", "qa", "report"]
            )
            
            test_results.append({
                "test_type": "github_report",
                "success": issue_result['success']
            })
            
        except Exception as e:
            test_results.append({
                "test_type": "github_report",
                "success": False,
                "error": str(e)
            })
        
        return {
            "project": project_name,
            "agent": self.agent_type,
            "test_results": test_results,
            "overall_success": passed_tests == total_tests,
            "success_rate": f"{(passed_tests/total_tests)*100:.1f}%",
            "timestamp": datetime.utcnow().isoformat()
        }


class DevOpsDeploymentMCPExample:
    """
    Example showing how DevOps Deployment agent uses MCP tools
    for infrastructure management, deployment automation, and monitoring
    """
    
    def __init__(self, bridge):
        self.bridge = bridge
        self.agent_type = "devops_deployment"
    
    async def deploy_full_stack_app(self, project_name: str) -> Dict[str, Any]:
        """Example: Complete deployment workflow"""
        deployment_steps = []
        
        # 1. Create deployment configuration
        k8s_config = f'''
apiVersion: apps/v1
kind: Deployment
metadata:
  name: {project_name}-api
  labels:
    app: {project_name}-api
spec:
  replicas: 3
  selector:
    matchLabels:
      app: {project_name}-api
  template:
    metadata:
      labels:
        app: {project_name}-api
    spec:
      containers:
      - name: api
        image: {project_name}:latest
        ports:
        - containerPort: 8000
        env:
        - name: DATABASE_URL
          valueFrom:
            secretKeyRef:
              name: {project_name}-secrets
              key: database-url
---
apiVersion: v1
kind: Service
metadata:
  name: {project_name}-service
spec:
  selector:
    app: {project_name}-api
  ports:
    - protocol: TCP
      port: 80
      targetPort: 8000
  type: LoadBalancer
'''
        
        config_result = await self.bridge.filesystem_write(
            f"{project_name}/k8s-deployment.yaml",
            k8s_config
        )
        deployment_steps.append({
            "step": "k8s_config",
            "success": config_result['success']
        })
        
        # 2. Create CI/CD pipeline
        github_actions = f'''
name: Deploy {project_name}

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: ubuntu-latest
    services:
      postgres:
        image: postgres:13
        env:
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: test_db
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Set up Python
      uses: actions/setup-python@v3
      with:
        python-version: '3.11'
    
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
    
    - name: Run tests
      run: |
        python -m pytest tests/ -v
    
  deploy:
    needs: test
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Build and push Docker image
      env:
        DOCKER_REGISTRY: ${{{{ secrets.DOCKER_REGISTRY }}}}
      run: |
        docker build -t $DOCKER_REGISTRY/{project_name}:${{{{ github.sha }}}} .
        docker push $DOCKER_REGISTRY/{project_name}:${{{{ github.sha }}}}
    
    - name: Deploy to Kubernetes
      run: |
        kubectl apply -f k8s-deployment.yaml
        kubectl set image deployment/{project_name}-api api=$DOCKER_REGISTRY/{project_name}:${{{{ github.sha }}}}
'''
        
        pipeline_result = await self.bridge.filesystem_write(
            f"{project_name}/.github/workflows/deploy.yml",
            github_actions
        )
        deployment_steps.append({
            "step": "ci_cd_pipeline",
            "success": pipeline_result['success']
        })
        
        # 3. Create monitoring configuration
        monitoring_config = f'''
version: '3.8'

services:
  prometheus:
    image: prom/prometheus
    ports:
      - "9090:9090"
    volumes:
      - ./prometheus.yml:/etc/prometheus/prometheus.yml
    command:
      - '--config.file=/etc/prometheus/prometheus.yml'
      - '--storage.tsdb.path=/prometheus'
      
  grafana:
    image: grafana/grafana
    ports:
      - "3000:3000"
    environment:
      - GF_SECURITY_ADMIN_PASSWORD=admin
    volumes:
      - grafana_data:/var/lib/grafana
      
  {project_name}-exporter:
    image: {project_name}:latest
    ports:
      - "8080:8080"
    command: ["python", "metrics_exporter.py"]
    
volumes:
  grafana_data:
'''
        
        monitoring_result = await self.bridge.filesystem_write(
            f"{project_name}/docker-compose.monitoring.yml",
            monitoring_config
        )
        deployment_steps.append({
            "step": "monitoring_setup",
            "success": monitoring_result['success']
        })
        
        # 4. Create backup script
        backup_script = f'''#!/bin/bash

# Backup script for {project_name}
DATE=$(date +%Y%m%d_%H%M%S)
BACKUP_DIR="/backups/{project_name}"
DB_CONTAINER="postgres"

# Create backup directory
mkdir -p $BACKUP_DIR

# Database backup
docker exec $DB_CONTAINER pg_dump -U postgres {project_name} > $BACKUP_DIR/db_backup_$DATE.sql

# File system backup
tar -czf $BACKUP_DIR/files_backup_$DATE.tar.gz /app/uploads /app/static

# Upload to cloud storage (example with AWS S3)
aws s3 cp $BACKUP_DIR/db_backup_$DATE.sql s3://backups/{project_name}/db/
aws s3 cp $BACKUP_DIR/files_backup_$DATE.tar.gz s3://backups/{project_name}/files/

# Cleanup old local backups (keep last 7 days)
find $BACKUP_DIR -name "*.sql" -mtime +7 -delete
find $BACKUP_DIR -name "*.tar.gz" -mtime +7 -delete

echo "Backup completed: $DATE"
'''
        
        backup_result = await self.bridge.filesystem_write(
            f"{project_name}/scripts/backup.sh",
            backup_script
        )
        deployment_steps.append({
            "step": "backup_script",
            "success": backup_result['success']
        })
        
        # 5. Test deployment with Docker
        try:
            # Build test container
            docker_result = await self.bridge.docker_run(
                image="docker",
                command=f"build -t {project_name}-test ."
            )
            deployment_steps.append({
                "step": "docker_build_test",
                "success": docker_result.get('success', False),
                "output": docker_result.get('result', '')
            })
        except Exception as e:
            deployment_steps.append({
                "step": "docker_build_test",
                "success": False,
                "error": str(e)
            })
        
        # 6. Create deployment summary issue
        try:
            successful_steps = len([s for s in deployment_steps if s['success']])
            total_steps = len(deployment_steps)
            
            summary = f'''
# Deployment Configuration Complete - {project_name}

## Deployment Summary
- **Configuration Steps**: {successful_steps}/{total_steps} completed
- **Success Rate**: {(successful_steps/total_steps)*100:.1f}%
- **Timestamp**: {datetime.utcnow().isoformat()}

## Created Configurations

âœ… **Kubernetes Deployment**: Production-ready k8s configuration
âœ… **CI/CD Pipeline**: GitHub Actions workflow  
âœ… **Monitoring Stack**: Prometheus + Grafana setup
âœ… **Backup Strategy**: Automated backup scripts
âœ… **Docker Build**: Container build and test

## Next Steps

1. **Configure Secrets**: Set up environment variables and secrets
2. **DNS Setup**: Configure domain and SSL certificates  
3. **Database Migration**: Run initial database setup
4. **Monitoring Setup**: Deploy monitoring stack
5. **Load Testing**: Verify performance under load

## Production Checklist

- [ ] Environment variables configured
- [ ] SSL certificates installed
- [ ] Database backups scheduled
- [ ] Monitoring alerts configured
- [ ] Log aggregation setup
- [ ] Security scanning completed

## Rollback Plan

In case of deployment issues:
1. Revert to previous Docker image tag
2. Scale down new deployment
3. Restore database from backup if needed
4. Check application logs for errors

## Monitoring URLs

- **Application**: https://{project_name}.example.com
- **Grafana**: https://monitoring.{project_name}.example.com:3000
- **Prometheus**: https://monitoring.{project_name}.example.com:9090
'''
            
            issue_result = await self.bridge.github_create_issue(
                title=f"Deployment Configuration Ready - {project_name}",
                body=summary,
                labels=["deployment", "devops", "production"]
            )
            
            deployment_steps.append({
                "step": "github_summary",
                "success": issue_result['success']
            })
            
        except Exception as e:
            deployment_steps.append({
                "step": "github_summary", 
                "success": False,
                "error": str(e)
            })
        
        return {
            "project": project_name,
            "agent": self.agent_type,
            "deployment_steps": deployment_steps,
            "total_success": successful_steps == total_steps,
            "configurations_created": [
                "Kubernetes deployment manifest",
                "GitHub Actions CI/CD pipeline",
                "Docker Compose monitoring stack", 
                "Automated backup scripts",
                "Production deployment summary"
            ],
            "timestamp": datetime.utcnow().isoformat()
        }


# Integration test runner
async def run_integration_examples():
    """
    Run all integration examples to demonstrate MCP functionality
    This would be called with actual MCP bridge instances
    """
    print("ðŸª¸ CoralCollective MCP Integration Examples")
    print("=" * 50)
    
    # Note: In actual usage, these would be initialized with real MCP bridges
    examples = {
        "Backend Developer": "Setting up API project with database and Docker deployment",
        "Frontend Developer": "Creating React project with performance optimization",
        "QA Testing": "Running comprehensive test suite with E2B execution",
        "DevOps Deployment": "Complete deployment pipeline with monitoring"
    }
    
    for agent, description in examples.items():
        print(f"\nðŸ”§ {agent}")
        print(f"   {description}")
        print("   âœ… MCP tools: GitHub, Filesystem, Database, E2B, Docker")
        
    print(f"\nðŸ“Š Example demonstrates:")
    print("   â€¢ File system operations (create, read, write)")
    print("   â€¢ Database interactions (schema, queries)")  
    print("   â€¢ GitHub integration (issues, repositories)")
    print("   â€¢ Docker operations (build, run, compose)")
    print("   â€¢ E2B code execution (testing, validation)")
    print("   â€¢ Web search (research, documentation)")
    
    print("\nðŸŽ¯ Key Benefits:")
    print("   â€¢ Agents can directly manipulate project files")
    print("   â€¢ Database operations with proper permissions")
    print("   â€¢ Automated testing and validation")
    print("   â€¢ Seamless deployment workflows")
    print("   â€¢ Real-time error handling and fallbacks")

if __name__ == "__main__":
    asyncio.run(run_integration_examples())